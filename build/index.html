<!DOCTYPE HTML>
<html>
<head>
  <title>Evil Wood</title>
  <style>html, body {
  padding: 0;
  margin: 0;
  overflow: hidden;
}

canvas {
  background-color: #1e1e0e;
}

/* vertical crosshair bar */
#a {
  width: 2px;
  height: 40px;
  position: fixed;
  left: 50%;
  margin-left: -1px;
  top: 50%;
  margin-top: -20px;
  background-color: rgba(255, 255, 255, 0.7);
}

/* horizontal crosshair bar */
#b {
  width: 40px;
  height: 2px;
  position: fixed;
  left: 50%;
  margin-left: -20px;
  top: 50%;
  margin-top: -1px;
  background-color: rgba(255, 255, 255, 0.7);
}</style>
</head>
<body>
  <canvas id="scene"></canvas>
  <script>// glMatrix v0.9.5
glMatrixArrayType=typeof Float32Array!="undefined"?Float32Array:typeof WebGLFloatArray!="undefined"?WebGLFloatArray:Array;
var vec3={};
vec3.create=function(a){var b=new glMatrixArrayType(3);if(a){b[0]=a[0];b[1]=a[1];b[2]=a[2]}return b};
vec3.scale=function(a,b,c){if(!c||a==c){a[0]*=b;a[1]*=b;a[2]*=b;return a}c[0]=a[0]*b;c[1]=a[1]*b;c[2]=a[2]*b;return c};
vec3.normalize=function(a,b){b||(b=a);var c=a[0],d=a[1],e=a[2],g=Math.sqrt(c*c+d*d+e*e);if(g){if(g==1){b[0]=c;b[1]=d;b[2]=e;return b}}else{b[0]=0;b[1]=0;b[2]=0;return b}g=1/g;b[0]=c*g;b[1]=d*g;b[2]=e*g;return b};
var mat3={};
mat3.create=function(a){var b=new glMatrixArrayType(9);if(a){b[0]=a[0];b[1]=a[1];b[2]=a[2];b[3]=a[3];b[4]=a[4];b[5]=a[5];b[6]=a[6];b[7]=a[7];b[8]=a[8];b[9]=a[9]}return b};
mat3.transpose=function(a,b){if(!b||a==b){var c=a[1],d=a[2],e=a[5];a[1]=a[3];a[2]=a[6];a[3]=c;a[5]=a[7];a[6]=d;a[7]=e;return a}b[0]=a[0];b[1]=a[3];b[2]=a[6];b[3]=a[1];b[4]=a[4];b[5]=a[7];b[6]=a[2];b[7]=a[5];b[8]=a[8];return b};
var mat4={};
mat4.set=function(a,b){b[0]=a[0];b[1]=a[1];b[2]=a[2];b[3]=a[3];b[4]=a[4];b[5]=a[5];b[6]=a[6];b[7]=a[7];b[8]=a[8];b[9]=a[9];b[10]=a[10];b[11]=a[11];b[12]=a[12];b[13]=a[13];b[14]=a[14];b[15]=a[15];return b};mat4.identity=function(a){a[0]=1;a[1]=0;a[2]=0;a[3]=0;a[4]=0;a[5]=1;a[6]=0;a[7]=0;a[8]=0;a[9]=0;a[10]=1;a[11]=0;a[12]=0;a[13]=0;a[14]=0;a[15]=1;return a};
mat4.create=function(a){var b=new glMatrixArrayType(16);if(a){b[0]=a[0];b[1]=a[1];b[2]=a[2];b[3]=a[3];b[4]=a[4];b[5]=a[5];b[6]=a[6];b[7]=a[7];b[8]=a[8];b[9]=a[9];b[10]=a[10];b[11]=a[11];b[12]=a[12];b[13]=a[13];b[14]=a[14];b[15]=a[15]}return b};
mat4.identity=function(a){a[0]=1;a[1]=0;a[2]=0;a[3]=0;a[4]=0;a[5]=1;a[6]=0;a[7]=0;a[8]=0;a[9]=0;a[10]=1;a[11]=0;a[12]=0;a[13]=0;a[14]=0;a[15]=1;return a};
mat4.toMat3=function(a,b){b||(b=mat3.create());b[0]=a[0];b[1]=a[1];b[2]=a[2];b[3]=a[4];b[4]=a[5];b[5]=a[6];b[6]=a[8];b[7]=a[9];b[8]=a[10];return b};
mat4.toInverseMat3=function(a,b){var c=a[0],d=a[1],e=a[2],g=a[4],f=a[5],h=a[6],i=a[8],j=a[9],k=a[10],l=k*f-h*j,o=-k*g+h*i,m=j*g-f*i,n=c*l+d*o+e*m;if(!n)return null;n=1/n;b||(b=mat3.create());b[0]=l*n;b[1]=(-k*d+e*j)*n;b[2]=(h*d-e*f)*n;b[3]=o*n;b[4]=(k*c-e*i)*n;b[5]=(-h*c+e*g)*n;b[6]=m*n;b[7]=(-j*c+d*i)*n;b[8]=(f*c-d*g)*n;return b};
mat4.multiply=function(a,b,c){c||(c=a);var d=a[0],e=a[1],g=a[2],f=a[3],h=a[4],i=a[5],j=a[6],k=a[7],l=a[8],o=a[9],m=a[10],n=a[11],p=a[12],r=a[13],s=a[14];a=a[15];var A=b[0],B=b[1],t=b[2],u=b[3],v=b[4],w=b[5],x=b[6],y=b[7],z=b[8],C=b[9],D=b[10],E=b[11],q=b[12],F=b[13],G=b[14];b=b[15];c[0]=A*d+B*h+t*l+u*p;c[1]=A*e+B*i+t*o+u*r;c[2]=A*g+B*j+t*m+u*s;c[3]=A*f+B*k+t*n+u*a;c[4]=v*d+w*h+x*l+y*p;c[5]=v*e+w*i+x*o+y*r;c[6]=v*g+w*j+x*m+y*s;c[7]=v*f+w*k+x*n+y*a;c[8]=z*d+C*h+D*l+E*p;c[9]=z*e+C*i+D*o+E*r;c[10]=z*
g+C*j+D*m+E*s;c[11]=z*f+C*k+D*n+E*a;c[12]=q*d+F*h+G*l+b*p;c[13]=q*e+F*i+G*o+b*r;c[14]=q*g+F*j+G*m+b*s;c[15]=q*f+F*k+G*n+b*a;return c};
mat4.translate=function(a,b,c){var d=b[0],e=b[1];b=b[2];if(!c||a==c){a[12]=a[0]*d+a[4]*e+a[8]*b+a[12];a[13]=a[1]*d+a[5]*e+a[9]*b+a[13];a[14]=a[2]*d+a[6]*e+a[10]*b+a[14];a[15]=a[3]*d+a[7]*e+a[11]*b+a[15];return a}var g=a[0],f=a[1],h=a[2],i=a[3],j=a[4],k=a[5],l=a[6],o=a[7],m=a[8],n=a[9],p=a[10],r=a[11];c[0]=g;c[1]=f;c[2]=h;c[3]=i;c[4]=j;c[5]=k;c[6]=l;c[7]=o;c[8]=m;c[9]=n;c[10]=p;c[11]=r;c[12]=g*d+j*e+m*b+a[12];c[13]=f*d+k*e+n*b+a[13];c[14]=h*d+l*e+p*b+a[14];c[15]=i*d+o*e+r*b+a[15];return c};
mat4.scale=function(a,b,c){var d=b[0],e=b[1];b=b[2];if(!c||a==c){a[0]*=d;a[1]*=d;a[2]*=d;a[3]*=d;a[4]*=e;a[5]*=e;a[6]*=e;a[7]*=e;a[8]*=b;a[9]*=b;a[10]*=b;a[11]*=b;return a}c[0]=a[0]*d;c[1]=a[1]*d;c[2]=a[2]*d;c[3]=a[3]*d;c[4]=a[4]*e;c[5]=a[5]*e;c[6]=a[6]*e;c[7]=a[7]*e;c[8]=a[8]*b;c[9]=a[9]*b;c[10]=a[10]*b;c[11]=a[11]*b;c[12]=a[12];c[13]=a[13];c[14]=a[14];c[15]=a[15];return c};
mat4.rotate=function(a,b,c,d){var e=c[0],g=c[1];c=c[2];var f=Math.sqrt(e*e+g*g+c*c);if(!f)return null;if(f!=1){f=1/f;e*=f;g*=f;c*=f}var h=Math.sin(b),i=Math.cos(b),j=1-i;b=a[0];f=a[1];var k=a[2],l=a[3],o=a[4],m=a[5],n=a[6],p=a[7],r=a[8],s=a[9],A=a[10],B=a[11],t=e*e*j+i,u=g*e*j+c*h,v=c*e*j-g*h,w=e*g*j-c*h,x=g*g*j+i,y=c*g*j+e*h,z=e*c*j+g*h;e=g*c*j-e*h;g=c*c*j+i;if(d){if(a!=d){d[12]=a[12];d[13]=a[13];d[14]=a[14];d[15]=a[15]}}else d=a;d[0]=b*t+o*u+r*v;d[1]=f*t+m*u+s*v;d[2]=k*t+n*u+A*v;d[3]=l*t+p*u+B*
v;d[4]=b*w+o*x+r*y;d[5]=f*w+m*x+s*y;d[6]=k*w+n*x+A*y;d[7]=l*w+p*x+B*y;d[8]=b*z+o*e+r*g;d[9]=f*z+m*e+s*g;d[10]=k*z+n*e+A*g;d[11]=l*z+p*e+B*g;return d};
mat4.frustum=function(a,b,c,d,e,g,f){f||(f=mat4.create());var h=b-a,i=d-c,j=g-e;f[0]=e*2/h;f[1]=0;f[2]=0;f[3]=0;f[4]=0;f[5]=e*2/i;f[6]=0;f[7]=0;f[8]=(b+a)/h;f[9]=(d+c)/i;f[10]=-(g+e)/j;f[11]=-1;f[12]=0;f[13]=0;f[14]=-(g*e*2)/j;f[15]=0;return f};
mat4.perspective=function(a,b,c,d,e){a=c*Math.tan(a*Math.PI/360);b=a*b;return mat4.frustum(-b,b,-a,a,c,d,e)};

var MATH_PI = Math.PI;
var MATH_ROUND = Math.round;
var MATH_RANDOM = Math.random;

function u_convertNegZeroToPosZero(val) {
  if (1/val === -Infinity) {
    return val * -1;
  }
  return val;
}
var mvMatrix = mat4.create(); 
var pMatrix = mat4.create();
var mvMatrixStack = [];

function gl_init() {
  // init depth test
  context.enable(context.DEPTH_TEST);
};

function gl_clear() {
  context.viewport(0, 0, canvas.width, canvas.height);
  context.clear(context.COLOR_BUFFER_BIT | context.DEPTH_BUFFER_BIT);
};

function gl_save() {
  var copy = mat4.create();
  mat4.set(mvMatrix, copy);
  mvMatrixStack.push(copy);
};

function gl_restore() {
  if (mvMatrixStack.length == 0) {
    throw 'Invalid popMatrix!';
  }
  mvMatrix = mvMatrixStack.pop();
};

function gl_initShaders() {
  gl_initPositionShader();
  gl_initTextureShader();
  gl_initNormalShader();
  gl_initLightingShader();
};

function gl_setShaderProgram(fragmentGLSL, vertexGLSL) {
  var fragmentShader = context.createShader(context.FRAGMENT_SHADER);
  context.shaderSource(fragmentShader, fragmentGLSL);
  context.compileShader(fragmentShader);
  
  var vertexShader = context.createShader(context.VERTEX_SHADER);
  context.shaderSource(vertexShader, vertexGLSL);
  context.compileShader(vertexShader);

  context.attachShader(shaderProgram, vertexShader);
  context.attachShader(shaderProgram, fragmentShader);
  context.linkProgram(shaderProgram);
  
  if (!context.getProgramParameter(shaderProgram, context.LINK_STATUS)) {
    alert('Could not initialize shaders');
  }
  
  context.useProgram(shaderProgram);
  
  // once shader program is loaded, it's time to init the shaders
  gl_initShaders();
};

function gl_perspective(viewAngle, minDist, maxDist) {
  mat4.perspective(viewAngle, canvas.width / canvas.height, minDist, maxDist, pMatrix);
};

function gl_identity() {
  mat4.identity(mvMatrix);
};

function gl_translate(x, y, z) {
  mat4.translate(mvMatrix, [x, y, z]);
};

function gl_rotate(angle, x, y, z) {
  mat4.rotate(mvMatrix, angle, [x, y, z]);
};

function gl_scale(x, y, z) {
  mat4.scale(mvMatrix, [x, y, z]);
};

function gl_initPositionShader() {
  shaderProgram.vertexPositionAttribute = context.getAttribLocation(shaderProgram, 'aVertexPosition');
  context.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);
  shaderProgram.pMatrixUniform = context.getUniformLocation(shaderProgram, 'uPMatrix');
  shaderProgram.mvMatrixUniform = context.getUniformLocation(shaderProgram, 'uMVMatrix');
};

function gl_initColorShader() {
  shaderProgram.vertexColorAttribute = context.getAttribLocation(shaderProgram, 'aVertexColor');
  context.enableVertexAttribArray(shaderProgram.vertexColorAttribute);
};

function gl_initTextureShader() {
  shaderProgram.textureCoordAttribute = context.getAttribLocation(shaderProgram, 'aTextureCoord');
  context.enableVertexAttribArray(shaderProgram.textureCoordAttribute);
  shaderProgram.samplerUniform = context.getUniformLocation(shaderProgram, 'uSampler');
};

function gl_initNormalShader() {
  shaderProgram.vertexNormalAttribute = context.getAttribLocation(shaderProgram, 'aVertexNormal');
  context.enableVertexAttribArray(shaderProgram.vertexNormalAttribute);
  shaderProgram.nMatrixUniform = context.getUniformLocation(shaderProgram, 'uNMatrix');
};

function gl_initLightingShader() {
  shaderProgram.useLightingUniform = context.getUniformLocation(shaderProgram, 'uUseLighting');
  shaderProgram.ambientColorUniform = context.getUniformLocation(shaderProgram, 'uAmbientColor');
  shaderProgram.pointLightingLocationUniform = context.getUniformLocation(shaderProgram, 'uPointLightingLocation');
  shaderProgram.pointLightingColorUniform = context.getUniformLocation(shaderProgram, 'uPointLightingColor');
};

function gl_initTexture(glTexture, image) {
  context.pixelStorei(context.UNPACK_FLIP_Y_WEBGL, true);
  context.bindTexture(context.TEXTURE_2D, glTexture);
  context.texImage2D(context.TEXTURE_2D, 0, context.RGBA, context.RGBA, context.UNSIGNED_BYTE, image);
  context.texParameteri(context.TEXTURE_2D, context.TEXTURE_MAG_FILTER, context.NEAREST);
  context.texParameteri(context.TEXTURE_2D, context.TEXTURE_MIN_FILTER, context.LINEAR_MIPMAP_NEAREST);
  context.generateMipmap(context.TEXTURE_2D);
  context.bindTexture(context.TEXTURE_2D, null);
};

function gl_createArrayBuffer(vertices) {
  var buffer = context.createBuffer();
  buffer.numElements = vertices.length;
  context.bindBuffer(context.ARRAY_BUFFER, buffer);
  context.bufferData(context.ARRAY_BUFFER, new Float32Array(vertices), context.STATIC_DRAW);
  return buffer;
};

function gl_createElementArrayBuffer(vertices) {
  var buffer = context.createBuffer();
  buffer.numElements = vertices.length;
  context.bindBuffer(context.ELEMENT_ARRAY_BUFFER, buffer);
  context.bufferData(context.ELEMENT_ARRAY_BUFFER, new Uint16Array(vertices), context.STATIC_DRAW);
  return buffer;
};

function gl_pushBuffers(buffers, texture) {
  // position buffers
  context.bindBuffer(context.ARRAY_BUFFER, buffers.position);
  context.vertexAttribPointer(shaderProgram.vertexPositionAttribute, 3, context.FLOAT, false, 0, 0);

  // texture buffers
  context.bindBuffer(context.ARRAY_BUFFER, buffers.texture);
  context.vertexAttribPointer(shaderProgram.textureCoordAttribute, 2, context.FLOAT, false, 0, 0);
  context.activeTexture(context.TEXTURE0);
  context.bindTexture(context.TEXTURE_2D, texture);
  context.uniform1i(shaderProgram.samplerUniform, 0);

  // index buffers
  context.bindBuffer(context.ELEMENT_ARRAY_BUFFER, buffers.index);

  // normal buffers
  context.bindBuffer(context.ARRAY_BUFFER, buffers.normal);
  context.vertexAttribPointer(shaderProgram.vertexNormalAttribute, 3, context.FLOAT, false, 0, 0);
};

function gl_setMatrixUniforms() {
  context.uniformMatrix4fv(shaderProgram.pMatrixUniform, false, pMatrix);
  context.uniformMatrix4fv(shaderProgram.mvMatrixUniform, false, mvMatrix);
  
  var normalMatrix = mat3.create();
  mat4.toInverseMat3(mvMatrix, normalMatrix);
  mat3.transpose(normalMatrix);
  context.uniformMatrix3fv(shaderProgram.nMatrixUniform, false, normalMatrix);
};

function gl_drawElements(buffers) {
  gl_setMatrixUniforms();
  
  // draw elements
  context.drawElements(context.TRIANGLES, buffers.index.numElements, context.UNSIGNED_SHORT, 0);
};

function l_drawArrays(buffers) {
  gl_setMatrixUniforms();
  
  // draw arrays
  context.drawArrays(context.TRIANGLES, 0, buffers.position.numElements / 3);
};

function gl_enableLighting() {
  context.uniform1i(shaderProgram.useLightingUniform, true);
};

function gl_setAmbientLighting(red, green, blue) {
  context.uniform3f(shaderProgram.ambientColorUniform, red, green, blue);
};

function gl_setPointLighting(red, green, blue) {
  context.uniform3f(shaderProgram.pointLightingColorUniform, red, green, blue);
}
function gl_getFragmentShaderGLSL() {
  return '#ifdef GL_ES\n' +
    'precision highp float;\n' +
    '#endif\n' +
    'varying vec2 vTextureCoord;\n' +
    'varying vec3 vLightWeighting;\n' +
    'uniform sampler2D uSampler;\n' +
    'void main(void) {\n' +
        'vec4 textureColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));\n' +
        'gl_FragColor = vec4(textureColor.rgb * vLightWeighting, textureColor.a);\n' +
    '}';
};

function gl_getVertexShaderGLSL() {
  return 'attribute vec3 aVertexPosition;\n' +
    'attribute vec3 aVertexNormal;\n' +
    'attribute vec2 aTextureCoord;\n' +

    'uniform mat4 uMVMatrix;\n' +
    'uniform mat4 uPMatrix;\n' +
    'uniform mat3 uNMatrix;\n' +

    'uniform vec3 uAmbientColor;\n' +

    'uniform vec3 uPointLightingLocation;\n' +
    'uniform vec3 uPointLightingColor;\n' +

    'uniform bool uUseLighting;\n' +

    'varying vec2 vTextureCoord;\n' +
    'varying vec3 vLightWeighting;\n' +

    'void main(void) {\n' +
        'vec4 mvPosition = uMVMatrix * vec4(aVertexPosition, 1.0);\n' +
        'gl_Position = uPMatrix * mvPosition;\n' +
        'vTextureCoord = aTextureCoord;\n' +

        'if (!uUseLighting) {\n' +
            'vLightWeighting = vec3(1.0, 1.0, 1.0);\n' +
        '} else {\n' +
            'vec3 lightDirection = normalize(uPointLightingLocation - mvPosition.xyz);\n' +

            'vec3 transformedNormal = uNMatrix * aVertexNormal;\n' +
            'float directionalLightWeighting = max(dot(transformedNormal, lightDirection), 0.0);\n' +
            'vLightWeighting = uAmbientColor + uPointLightingColor * directionalLightWeighting;\n' +
        '}\n' +
    '}'
};
var world = {
  blocks: {}
};

function w_init() {
  w_addBlock(0, 0);
  w_addBlocks();
}

function w_addBlock(x, z) {
  if (world.blocks[x] === undefined) {
    world.blocks[x] = {};
  }

  world.blocks[x][z] = {
    trees: []
  }

  var treeRange = 45;
  for (var n = 0; n < 20; n++) {
    world.blocks[x][z].trees.push({
      x: (MATH_RANDOM() * treeRange * 2) - treeRange,
      z: (MATH_RANDOM() * treeRange * 2) - treeRange,
      rotationY: MATH_RANDOM() * MATH_PI * 2,
      height: 60 + MATH_RANDOM() * 80
    });
  }
}

/*
 *     -
 *   1 2 3
 * - 8 0 4 +
 *   7 6 5 
 *     +
 */ 
function w_getSurroundingBlocks() {
  var x = u_convertNegZeroToPosZero(MATH_ROUND(camera.x/BLOCK_SIZE));
  var z = u_convertNegZeroToPosZero(MATH_ROUND(camera.z/BLOCK_SIZE));

  return [
    {x: x, z: z}, // 0
    {x: x-1, z: z-1}, // 1
    {x: x, z: z-1}, // 2
    {x: x+1, z: z-1}, // 3
    {x: x+1, z: z}, // 4
    {x: x+1, z: z+1}, // 5
    {x: x, z: z+1}, // 6
    {x: x-1, z: z+1}, // 7
    {x: x-1, z: z} // 8
  ];
}
   
function w_addBlocks() {
  var blocks = w_getSurroundingBlocks();

  blocks.forEach(function(block) {
    var bx = block.x;
    var bz = block.z;

    if (world.blocks[bx] === undefined) {
      world.blocks[bx] = {};
    }

    if (world.blocks[bx][bz] === undefined) {
      w_addBlock(bx, bz);
    }
  });
}

function w_isNearTree() {
  return true;
}

// constants
var PLAYER_SPEED = 40; // units / s

var player = {};

function p_init() {
  player = {
    straightMovement: 0,
    sideMovement: 0,
    isClimbing: false
  };
}
/*
  C     C#    D     Eb    E     F     F#    G     G#    A     Bb    B
0 16.35 17.32 18.35 19.45 20.60 21.83 23.12 24.50 25.96 27.50 29.14 30.87
1 32.70 34.65 36.71 38.89 41.20 43.65 46.25 49.00 51.91 55.00 58.27 61.74
2 65.41 69.30 73.42 77.78 82.41 87.31 92.50 98.00 103.8 110.0 116.5 123.5
3 130.8 138.6 146.8 155.6 164.8 174.6 185.0 196.0 207.7 220.0 233.1 246.9
4 261.6 277.2 293.7 311.1 329.6 349.2 370.0 392.0 415.3 440.0 466.2 493.9
5 523.3 554.4 587.3 622.3 659.3 698.5 740.0 784.0 830.6 880.0 932.3 987.8
6 1047  1109  1175  1245  1319  1397  1480  1568  1661  1760  1865  1976
7 2093  2217  2349  2489  2637  2794  2960  3136  3322  3520  3729  3951
8 4186  4435  4699  4978  5274  5588  5920  6272  6645  7040  7459  7902
*/

var THEME_MUSIC = 

  // [frequency, duration, wait]
  // notes: [
  //   [25, 1],
  //   [50, 1]
  // ]
  // bass: [
  //   [82.41, 0.4, 0.6],
  //   [82.41, 0.15, 1.9],

  //   [82.41, 0.4, 0.55],
  //   [82.41, 0.15, 1.9],

  //   [61.74, 0.4, 0.55],
  //   [61.74, 0.15, 1.9],

  //   [61.74, 0.4, 0.55],
  //   [61.74, 0.15, 1.9],

  //   [55, 0.4, 0.55],
  //   [55, 0.15, 1.9],

  //   [55, 0.4, 0.55],
  //   [55, 0.15, 1.9],

  //   [82.41, 0.4, 0.55],
  //   [82.41, 0.15, 1.9],

  //   [82.41, 0.4, 0.55],
  //   [82.41, 0.15, 1.9],
  // ]
[
  [82.41, 0.4, 0.6],
  [82.41, 0.4, 0.6],
  [82.41, 0.13, 0.15],
  [87.31, 0.13, 0.15],
  [92.50, 0.13, 0.15],
  [98, 0.13, 0.15],
  [92.50, 0.13, 0.3],
  [98, 0.2, 0.3],

  [82.41, 0.4, 0.6],
  [82.41, 0.4, 0.6],
  [82.41, 0.13, 0.15],
  [87.31, 0.13, 0.15],
  [92.50, 0.13, 0.15],
  [98, 0.13, 0.15],
  [92.50, 0.13, 0.3],
  [98, 0.2, 0.3],

  [61.74, 0.4, 0.6],
  [61.74, 0.4, 0.6],
  [61.74, 0.13, 0.15],
  [65.41, 0.13, 0.15],
  [69.30, 0.13, 0.15],
  [73.42, 0.13, 0.15],
  [69.30, 0.13, 0.3],
  [73.42, 0.2, 0.3],

  [61.74, 0.4, 0.6],
  [61.74, 0.4, 0.6],
  [61.74, 0.13, 0.15],
  [65.41, 0.13, 0.15],
  [69.30, 0.13, 0.15],
  [73.42, 0.13, 0.15],
  [69.30, 0.13, 0.3],
  [73.42, 0.2, 0.3],


  // [82.41, 0.4, 0.55],
  // [82.41, 0.15, 1.9],

  // [61.74, 0.4, 0.55],
  // [61.74, 0.15, 1.9],

  // [61.74, 0.4, 0.55],
  // [61.74, 0.15, 1.9],

  // [55, 0.4, 0.55],
  // [55, 0.15, 1.9],

  // [55, 0.4, 0.55],
  // [55, 0.15, 1.9],

  // [82.41, 0.4, 0.55],
  // [82.41, 0.15, 1.9],

  // [82.41, 0.4, 0.55],
  // [82.41, 0.15, 1.9]
]


var audioContext = new AudioContext()
var gain = audioContext.createGain();

function a_init() {
  gain.connect(audioContext.destination);

  gain.gain.value = 0;

  a_playMusic();

  //gain.gain.exponentialRampToValueAtTime(0.00001, audioContext.currentTime + 1);
}

function a_playMusic() {
  var time = 0;

  gain.gain.value = 1;

  THEME_MUSIC.forEach(function(note, n) {
    var freq = note[0];
    var duration = note[1];
    var wait = note[2];

    a_playNote(freq, time, duration);
    time+=wait;
  });
}

function a_playNote(freq, start, duration) {
  var oscillator = audioContext.createOscillator();

  oscillator.connect(gain);
  oscillator.frequency.value = freq;
  oscillator.type = 'square';
  
  console.log(freq, start, duration)
  oscillator.start(audioContext.currentTime + start);
  oscillator.stop(audioContext.currentTime + start + duration);
}
/*
 * The view is responsible for the camera, loading textures, and rendering the world model
 */
var canvas = document.getElementById('scene');
var context = canvas.getContext('webgl');
var shaderProgram = context.createProgram();
var camera = {
  x: 0,
  y: 6,
  z: 0,
  pitch: 0,
  yaw: 0
};
var textures = {};

function v_init() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  
  gl_setShaderProgram(gl_getFragmentShaderGLSL(), gl_getVertexShaderGLSL());

  v_loadTextures(function() {
    c_gameLoop();

  });
}

function v_loadTextures(callback) {
  textures = {
    tree: {
      encoding: 'data:image/gif;base64,R0lGODlhEAAQAPcAAAAAAP///0RIOz9AOFBRR0REOlNTS1dWPVZVQ0RDNElIOkpJO0pJPFFQQ1RTSFZVTEE/MVFPP1NRQlRSQ1dVRkZDMktINj89MUNBNlBOQUtJPVJQQ1pYS1BNPVFOQF1aS11bUVRQPlFNPVxYR0A+NVpXS15bT2ZjV0pIQEhBJ1hROElEMVtWRF5ZR0pGOFhURlBNQkdFPkA4Hk5GLUA6J0Q+K0hCLjw3J0ZBMVxWQ1NOPkhENz88MlRQQ0lBKkY/KlhPN05IODg0KVNOP1RPQGNdTEA8MUZCNkRANUZCN1lVSV5aTkZDO0c+J0I6JzEsH05GMzYxJE5HNkU/MGhfSVpTQk9JOltUQ2JbSUpFOEZBNVdSRkhEOlpVSUM3HD4zGkg+J0Y8JkxCLEpBLEU9Kz43J0E6Ki4pHktDMTo0JkI7LDs1KEA6LFVNO0dBM1tTQklDNVxUQ1BKPEA7MFZQQlZQQ0Y5Hz0zHz41I1BFLkg+KktCL1lPOkc/L1lQPkY/MTw2KlFJOUdAMj03K0tENlhQQFpSQkZANFhRQ1dQQkM+NFROQjYmCTcpEEAzGzwxHDYsGj4zHzYtHUM5JjMrHU1CLSokGU9EMDoyJDszJU1DMUc+LTcwIz01J1RJNkI6K0Q8LVpQPTUvJFNKOUc/MUE6LUlBM0Y/MlFJOlRMPVVNP1NMP1dQQ0ZBOD0xHSggEzUrGjowHycgFT0zIj40Iz40JEg9K0M5KUA3KEE4KUI5KkxCMlBGNUA4K1FHNz84LFRLPEI7Lz85LzImFT8yH0c5JDMpGkg7J0U5JzUsHkI3JkE2Jkc7KjEpHT81Jko+LUY7KzQsIEg9LVFFNEY9L1ZLOklAMzkyKExDNk9IPk5IPzMnF0I0IUAzITcsHTMpG0s8KEM2JEU4JkE1JTQrH0c7K1JFNDoxJUk/MjstHDkuIT4zJkc8LlFGOCkdDyccEDUsIjYtIzszKlFGOjcnFzgtIjgoGTszLDYmGgAAAAAAAAAAAAAAAAAAAAAAAAAAACwAAAAAEAAQAAAI/wAX6OgUzVwhF4qYWMn07VKVBgrAVJJGj5mUAg/GgJNzhJcgHkRUHFN3SxkUVSb4FMtVB52yalgQ7OozIdK0dqg8qKkVihsyPzl+VOjQAw8kJFpq2GgzytUwNuRS0BCQoNcdOO+++LCwphksOLLsGAMkZlYiYJS8SIoy7lyGInIYPWJgC9QGT38aOcIRq5QEKm9k6BlwBg2LKfdohSHxZE8LESsOALFWj9AQCAQi5FlkYEmWGyE0zXCGTZOvFyVMNdEFgk65Kx/wdWNAYdIzbdnseUtiKJw4DlvYLTvEihimGHOgjTuVKh2nVvEErQuGYtsmGK/K4PolzJ0oLpbIyCQzgiFZHERpnAy6FgWekhFuPgXZcYHavC4azAQiJeTXqhMOBAQAOw=='
    },
    metalFloor: {
      encoding: 'data:image/gif;base64,R0lGODlhEAAQAPcAAAAAAP///2lkZSgmJ29tbjExMlhZXjM0NS8xMj1BQjM3Ny4vLyYsKyMmJVZbWScsKVdcWSwxLCYoJklMSSguJjg9NjM9LjI0MTM4MDM2MR4fHURFQz9GNzM3Li46HkJFPi48GTA+GiEnGDI3Ki8zKTs/NTg6NTY4MzM8Iz9ILzM6JzxCMjU4MDdDITQ6KSowHlJbPywwJERKODEzLTM1Lzo8NkNEQSo4Cio0EjxKGyoyFx0iEkJLLi4xJ0tQQE1QRjtGHjZAHURLMSQpFiAkFBETCxodETE2IysuIjs+Mi8xKRscGDk7M1RWTltcWDE4GTA2HTAzJjI1KDU3Lj0/NkpSKyouGzs/Kzk9Kjg6MEhKQDU5JDk8LCwuIyktFEJHKS0wHCEjFjU4Ji8xJB8gGkhKPVBSRTU6GDE0HiIkFkJFMCwuIDs9LkFDNTc4MSotFDc7Gzc6IldbOjM1Ij5AL0BCMjIzKkVGPklKQltcUywuFSUnEy8xGTM1IVVXPjQ1Kz9ANTQ2GCkqGCkqG0dIODo7JD0+JzY3Izk6JjY3JFRVOywsGjk5JzIyJS8vI0tLOEBAMjg4LSkpIUlJPzo6MyoqJlxcVFNTTCkpJklJRUVFQSQkIktLSCIhETY1I0hHNEE/KEdFLkNCNUA/M1dWSygmEzg1GzUzIUA+LUxKOU1MQk5NREA+LyUkHS0sJUpJQj47KktINzEvJFFOPTs5LV5bSTw6L0ZEN1RSRVRSR1xaTj08Nk5HIj88LC0rITs5L1hVR2FeUFxaUDQzLklIQzIuHTc0KC0rIjY0K15bTlhVSTUzLElHQE9NRjItHDw3Jz06MGplVEZDOWZjWTEsHTArHVdONkVAMVFLOjs3LDQxKFhTRTk2LU5KPk5LQnBuaC4nFkA7LmBcUlFJOD85LGBbUFVSS2BaThsaGG5qYkM6Ky8pH0hBNUNAO0tJRlRSTzcsHUY4JTctID86M2BbVD06NkpGQVBMSDYxLwAAAAAAAAAAAAAAAAAAAAAAAAAAACwAAAAAEAAQAAAI/wDXUAghhAuNA12iUIHGTdo4a9ES1OiAIUODB0kiMPAB6ZAWAxDy6JpWiQyaQvgwzXkCJ44KB2WwBcN1zMgZXvGeBXqjCE+PPsVGMWMyJlEbG8tkDYoxwR0xZI5mDFMmZpIZDiNu0WFjgcW8VSVOOLnERMGRLzBWsLliRUSaKRU4bViioYgJAnJugIFS6hQjVzOQkEDma5MEN7MQ1WnBQw0le9mIvLBFrpqxXa/ubeNjKJS8cKyUhPECKJcwVY9qxfpkChw1T7R+rduDpcmGRr3OJfPTTdsfVKngqZM0RE+nRa3qtYNF7504UtnYRbpjZ4cOKQguLEDX7Fs6Qls+uCSQQQMEjgGasnC7BsySOVBAcqTwICgIigKZflDxVs6ZKAFVBAQAOw=='
    },
    ceiling: {
      encoding: 'data:image/gif;base64,R0lGODlhEAAQAPcAAAAAAP///09gF0tXFVNgGUFKF1FcFkBID1hiFUhRE0ZOC0xUD01VEkdNE19oGk9WF1VdDkFGCzc7CjtAC1RbEGFpEzM3ClRaEzg8DU5TFVFWF1NZHEFFFmpwJD9DCjs+C1NYEVNXEk1SEj9CD0pOFnl+JVldHE9TG1daEVteE05REUlMEERHD1xfFUdJE2ltHVRWF0lLFVlcGl9iHFNVG2BjIFZYHVFTH0BBCT0+CT0+DVJUEkhJEFxdFUlKEUxNE11eGFtcGWprHy8wEDQ1ElpbIF9gJSEhAjAwCTg4C0pKD0VFDlNTEUlJDzs7DVdWFFVVFEREFElJFlVVGl1dHVpaHEtLGC0sBUxKElNRFkA/EUJBElBPFkFAEmRiHD08EVNRGUtJF1pYHEpJGUxLGmBeITY0CTAuCUE+DUpHEUZEE1JPF0hGFkhFFkdFF2RhImViI0VDGEZEGlNRIiEfAzMwCExHEDUyCz47Djs4DjIvDFNOFTw5D0xIFURAFE9LGExIF01JGEdDFmRfIFpVHVhTHTUxBzUxCkA7DUI9D0dCEUZBEkE8EUpFFEdCFElEFUE9E1BLGEM+FFNOHDw4Fz44DTs2DjItDElCE0E7E1lRHE9IGUU/F0I9Fjs2FFRNHVJMHU9JHEZBGldRIiUgATkyC0pCDzcxCy4pCiUhCC8qCzEsDFJJGFtSHVdOHE1GHElCG15WI1VNICwmCUM7EVlPGjQuEUtDGTkzEzEsEVNKIGJYJllQIzIqCkE4EUA4FEY9GE1EHEpBGzs0FlVLIFNJIVFIIicgBzMrDDsyEUtAF0tBHVZNKjYtED81E1RHHkc8GkU7G0k/HyAZBiUeCUw+FzMqEE1AGUQ5GkI4HDsyGUk7FjgtEkQ3GEQ5HDwwFCYeDS4lEE9AHUw+HUk9I2BSMjwuEzwvFkk6G08/H0s8IldGK1tILDouHVRCKUo4IVE/LDYoG0ExJQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACwAAAAAEAAQAAAI/wBvZIDxI5WFBhgc1GBgwogBAQTwOIlz7pAHJEmW8CBDwgWHARvYaJjhZZA4c6UwRaqyIoeWObFGoRBSwRGrWug0AXkCZQcIWLw2MXkh40sQU48mZdkTJhQVN8DAiCEErcuCP+s4pXnGbhcVLsxoFCLWRpQOG+UYfXgFb5ydFG+KCZIkDFs4da6q+Ukgy1kzR33MXEF16lg7d+mUoYkAiBY1PXzItUr0LV60MNI8SUiCK9MvLIvkZSvV7d01HKC8WTuzxVgwNchyrZrVy5AiX6Rscet0okifQ9OG3VJy51KlZOC0hZgyqkUQRFfgfFLRRNWjNcu29RBRpkSQBxCiHCQYAinGmEZ1jljygaCDLkp5iBQYYUUOHVWqJrBQQOFCICkjBAQAOw=='
    }
  };

  var loadedImages = 0;
  var numImages = 0;
  for (var key in textures) {
    (function() {
      numImages++;
      var texture = textures[key];
      var glTexture = texture.glTexture = context.createTexture();
      var image = texture.image = new Image();
      image.onload = function() {
        gl_initTexture(glTexture, image);
        if (++loadedImages >= numImages) {
          callback();
        }
      };
      
      image.src = texture.encoding;
    })();
  }
};

function v_renderGround(x, z) {
  gl_save();
  gl_translate(x * BLOCK_SIZE, -1.1, z * BLOCK_SIZE);
  gl_pushBuffers(buffers.plane, textures.metalFloor.glTexture);
  gl_drawElements(buffers.plane);
  gl_restore();
};

function v_renderTreeTops(x, z) {
  gl_save();
  gl_translate(x * BLOCK_SIZE, 25, z * BLOCK_SIZE);
  // use floor buffers with ceiling texture
  gl_pushBuffers(buffers.plane, textures.ceiling.glTexture);
  gl_drawElements(buffers.plane);
  gl_restore();
};

function v_renderTrees(x, z) {
  var trees = world.blocks[x][z].trees;

  for (var n = 0; n < trees.length; n++) {
    var tree = trees[n];
    var treeX = (x * BLOCK_SIZE) + tree.x;
    var treeY = (z * BLOCK_SIZE) + tree.z;

    for (var i = 0; i < tree.height/2; i++) {
      // trunk
      gl_save();
      gl_translate(treeX, i*2, treeY);
      gl_rotate(tree.rotationY, 0, 1, 0);
      gl_pushBuffers(buffers.cube, textures.tree.glTexture);
      gl_drawElements(buffers.cube);
      gl_restore();
    }

    // bottom level leaves
    gl_save();
    gl_translate(treeX, tree.height*0.4, treeY);
    gl_rotate(tree.rotationY, 0, 1, 0);
    gl_pushBuffers(buffers.smallPlane, textures.ceiling.glTexture);
    gl_drawElements(buffers.smallPlane);
    gl_restore();

    gl_save();
    gl_translate(treeX, tree.height*0.5, treeY);
    gl_rotate(tree.rotationY, 0, 1, 0);
    gl_scale(0.6, 1, 0.6);
    gl_pushBuffers(buffers.smallPlane, textures.ceiling.glTexture);
    gl_drawElements(buffers.smallPlane);
    gl_restore();

    gl_save();
    gl_translate(treeX, tree.height*0.6, treeY);
    gl_rotate(tree.rotationY, 0, 1, 0);
    gl_scale(0.5, 1, 0.5);
    gl_pushBuffers(buffers.smallPlane, textures.ceiling.glTexture);
    gl_drawElements(buffers.smallPlane);
    gl_restore();

    gl_save();
    gl_translate(treeX, tree.height*0.7, treeY);
    gl_rotate(tree.rotationY, 0, 1, 0);
    gl_scale(0.4, 1, 0.4);
    gl_pushBuffers(buffers.smallPlane, textures.ceiling.glTexture);
    gl_drawElements(buffers.smallPlane);
    gl_restore();

    gl_save();
    gl_translate(treeX, tree.height*0.8, treeY);
    gl_rotate(tree.rotationY, 0, 1, 0);
    gl_scale(0.3, 1, 0.3);
    gl_pushBuffers(buffers.smallPlane, textures.ceiling.glTexture);
    gl_drawElements(buffers.smallPlane);
    gl_restore();

    gl_save();
    gl_translate(treeX, tree.height*0.9, treeY);
    gl_rotate(tree.rotationY, 0, 1, 0);
    gl_scale(0.2, 1, 0.2);
    gl_pushBuffers(buffers.smallPlane, textures.ceiling.glTexture);
    gl_drawElements(buffers.smallPlane);
    gl_restore();

    // top level leaves
    gl_save();
    gl_translate(treeX, tree.height*0.98, treeY);
    gl_rotate(tree.rotationY, 0, 1, 0);
    gl_scale(0.1, 1, 0.1);
    gl_pushBuffers(buffers.smallPlane, textures.ceiling.glTexture);
    gl_drawElements(buffers.smallPlane);
    gl_restore();
  }
};

function v_renderBlocks() {
  // only render blocks potentially within view
  var blocks = w_getSurroundingBlocks();

  blocks.forEach(function(block) {
    var x = block.x;
    var z = block.z;
    v_renderGround(x, z);
    v_renderTrees(x, z);
    //v_renderTreeTops(x, z);
  });
}

function v_updateCameraPos() {

  if (player.straightMovement !== 0) {
    var direction = player.straightMovement === 1 ? -1 : 1;
    var distEachFrame = direction * PLAYER_SPEED * elapsedTime / 1000;

    if (player.isClimbing) {
      camera.y += distEachFrame * -1;
    }
    else {
      camera.z += distEachFrame * Math.cos(camera.yaw);
      camera.x += distEachFrame * Math.sin(camera.yaw);
    }
  }
  
  if (player.sideMovement !== 0) {
    var direction = player.sideMovement === 1 ? 1 : -1;
    var distEachFrame = direction * PLAYER_SPEED * elapsedTime / 1000;
    camera.z += distEachFrame * Math.cos(camera.yaw + Math.PI / 2);
    camera.x += distEachFrame * Math.sin(camera.yaw + Math.PI / 2);
  }


  
};

function v_render() {
  gl_clear();

  // set field of view at 45 degrees
  // set viewing range between 0.1 and 100 units away.
  gl_perspective(45, 0.1, 150.0);
  gl_identity();
  
  // enable lighting
  gl_enableLighting();
  gl_setAmbientLighting(0.5, 0.5, 0.5);


  //gl_setDirectionalLighting(-0.25, -0.25, -1, 0.8, 0.8, 0.8);
  gl_setPointLighting(0.5, 0.5, 0.5);

  gl_rotate(-camera.pitch, 1, 0, 0);
  gl_rotate(-camera.yaw, 0, 1, 0);
  gl_translate(-camera.x, -camera.y, -camera.z);
  
  v_renderBlocks();
};
// block width and height.  The world is made up of equal sized tiled blocks
var BLOCK_SIZE = 100;

var buffers = {
  cube: {
    position: gl_createArrayBuffer([    
      -1, -1, 1, 1, -1, 1, 1, 1, 1, -1, 1, 1, // Front face    
      -1, -1, -1, -1, 1, -1, 1, 1, -1, 1, -1, -1, // Back face    
      -1, 1, -1, -1, 1, 1, 1, 1, 1, 1, 1, -1, // Top face    
      -1, -1, -1, 1, -1, -1, 1, -1, 1, -1, -1, 1, // Bottom face    
      1, -1, -1, 1, 1, -1, 1, 1, 1, 1, -1, 1, // Right face    
      -1, -1, -1, -1, -1, 1, -1, 1, 1, -1, 1, -1 // Left face
    ]),
    normal: gl_createArrayBuffer([    
      0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, // Front face    
      0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, // Back face   
      0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, // Top face    
      0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, // Bottom face    
      1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, // Right face    
      -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0 // Left face
    ]),
    texture: gl_createArrayBuffer([    
      0, 0, 1, 0, 1, 1, 0, 1, // Front face   
      1, 0, 1, 1, 0, 1, 0, 0, // Back face   
      0, 1, 0, 0, 1, 0, 1, 1, // Top face    
      1, 1, 0, 1, 0, 0, 1, 0, // Bottom face   
      1, 0, 1, 1, 0, 1, 0, 0, // Right face    
      0, 0, 1, 0, 1, 1, 0, 1 // Left face
    ]),
    index: gl_createElementArrayBuffer([
      0, 1, 2, 0, 2, 3, // Front face
      4, 5, 6, 4, 6, 7, // Back face
      8, 9, 10, 8, 10, 11, // Top face
      12, 13, 14, 12, 14, 15, // Bottom face
      16, 17, 18, 16, 18, 19, // Right face
      20, 21, 22, 20, 22, 23 // Left face
    ])
  },
  plane: {
    position: gl_createArrayBuffer([
      -50, 0, -50, -50, 0, 50, 50, 0, 50, 50, 0, -50
    ]),
    normal: gl_createArrayBuffer([
      0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0
    ]),
    texture: gl_createArrayBuffer([
      0, 25, 0, 0, 25, 0, 25, 25
    ]),
    index: gl_createElementArrayBuffer([
      0, 1, 2, 0, 2, 3
    ])
  },
  smallPlane: {
    position: gl_createArrayBuffer([
      -20, 0, -20, -20, 0, 20, 20, 0, 20, 20, 0, -20
    ]),
    normal: gl_createArrayBuffer([
      0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0
    ]),
    texture: gl_createArrayBuffer([
      0, 10, 0, 0, 10, 0, 10, 10
    ]),
    index: gl_createElementArrayBuffer([
      0, 1, 2, 0, 2, 3
    ])
  }
}
var elapsedTime = 0;
var lastTime = 0;

function c_init() {
  gl_init(); // webgl
  w_init(); // world
  p_init(); // player
  v_init(); // view
  a_init(); // audio
  c_attachListeners();
}

function c_handleKeyDown(evt) {
  var keycode = ((evt.which) || (evt.keyCode));

  if (c_isPointerLocked()) {
    switch (keycode) {
      case 65:
        // a key
        player.sideMovement = -1;
        break;
      case 87:
        // w key
        player.straightMovement = 1;
        break;
      case 68:
        // d key
        player.sideMovement = 1;
        break;
      case 83:
        // s key
        player.straightMovement = -1;
        break;
      case 32:
        // space key
        player.isClimbing = true;
        break;
    }
  }
};

function c_handleKeyUp(evt) {
  var keycode = ((evt.which) || (evt.keyCode));

  switch (keycode) {
    case 65:
      // a key
      player.sideMovement = 0;
      break;
    case 87:
      // w key
      player.straightMovement = 0;
      break;
    case 68:
      // d key
      player.sideMovement = 0;
      break;
    case 83:
      // s key
      player.straightMovement = 0;
      break;
  }
};

function c_handleMouseMove(evt) {
  if (c_isPointerLocked()) {
    // pitch (up and down)
    camera.pitch += evt.movementY * MATH_PI * 0.001 * -1;
    if (camera.pitch > MATH_PI/2) {
      camera.pitch = MATH_PI/2;
    }
    if (camera.pitch < -1 * MATH_PI/2) {
      camera.pitch = -1 * MATH_PI/2;
    }

    // yaw (side to side)
    camera.yaw += evt.movementX * MATH_PI * 0.001 * -1;
  }
}

function c_isPointerLocked() {
  return document.pointerLockElement === canvas;
}

function c_handleClick(evt) {
  // if pointer is not locked
  if (!c_isPointerLocked()) {
    canvas.requestPointerLock();
  } 
}

function c_attachListeners() {
  document.addEventListener('keydown', function(evt) {
    c_handleKeyDown(evt);
  }, false);
  
  document.addEventListener('keyup', function(evt) {
    c_handleKeyUp(evt);
  }, false);

  document.addEventListener('mousemove', function(evt) {
    c_handleMouseMove(evt);
  }, false);

  document.addEventListener('click', function(evt) {
    c_handleClick(evt);
  }, false);
};

function c_gameLoop() {
  var time = new Date().getTime();
  if (lastTime !== 0) {
    elapsedTime = time - lastTime;
  }
  v_updateCameraPos();
  w_addBlocks();
  v_render();

  lastTime = time;

  window.requestAnimationFrame(c_gameLoop);  
} 

// initialize game controller
c_init();
</script>
  <div id="a"></div>
  <div id="b"></div>
</body>
</html>