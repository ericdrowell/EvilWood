<!DOCTYPE HTML><html><head><title>Evil Wood</title></head><body><canvas id="scene"></canvas><script>var GROUND_TEXTURE_ENCODING = 'data:image/gif;base64,R0lGODlhEAAQAPcAAAAAAP///09gF0tXFVNgGUFKF1FcFkBID1hiFUhRE0ZOC0xUD01VEkdNE19oGk9WF1VdDkFGCzc7CjtAC1RbEGFpEzM3ClRaEzg8DU5TFVFWF1NZHEFFFmpwJD9DCjs+C1NYEVNXEk1SEj9CD0pOFnl+JVldHE9TG1daEVteE05REUlMEERHD1xfFUdJE2ltHVRWF0lLFVlcGl9iHFNVG2BjIFZYHVFTH0BBCT0+CT0+DVJUEkhJEFxdFUlKEUxNE11eGFtcGWprHy8wEDQ1ElpbIF9gJSEhAjAwCTg4C0pKD0VFDlNTEUlJDzs7DVdWFFVVFEREFElJFlVVGl1dHVpaHEtLGC0sBUxKElNRFkA/EUJBElBPFkFAEmRiHD08EVNRGUtJF1pYHEpJGUxLGmBeITY0CTAuCUE+DUpHEUZEE1JPF0hGFkhFFkdFF2RhImViI0VDGEZEGlNRIiEfAzMwCExHEDUyCz47Djs4DjIvDFNOFTw5D0xIFURAFE9LGExIF01JGEdDFmRfIFpVHVhTHTUxBzUxCkA7DUI9D0dCEUZBEkE8EUpFFEdCFElEFUE9E1BLGEM+FFNOHDw4Fz44DTs2DjItDElCE0E7E1lRHE9IGUU/F0I9Fjs2FFRNHVJMHU9JHEZBGldRIiUgATkyC0pCDzcxCy4pCiUhCC8qCzEsDFJJGFtSHVdOHE1GHElCG15WI1VNICwmCUM7EVlPGjQuEUtDGTkzEzEsEVNKIGJYJllQIzIqCkE4EUA4FEY9GE1EHEpBGzs0FlVLIFNJIVFIIicgBzMrDDsyEUtAF0tBHVZNKjYtED81E1RHHkc8GkU7G0k/HyAZBiUeCUw+FzMqEE1AGUQ5GkI4HDsyGUk7FjgtEkQ3GEQ5HDwwFCYeDS4lEE9AHUw+HUk9I2BSMjwuEzwvFkk6G08/H0s8IldGK1tILDouHVRCKUo4IVE/LDYoG0ExJQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACwAAAAAEAAQAAAI/wBvZIDxI5WFBhgc1GBgwogBAQTwOIlz7pAHJEmW8CBDwgWHARvYaJjhZZA4c6UwRaqyIoeWObFGoRBSwRGrWug0AXkCZQcIWLw2MXkh40sQU48mZdkTJhQVN8DAiCEErcuCP+s4pXnGbhcVLsxoFCLWRpQOG+UYfXgFb5ydFG+KCZIkDFs4da6q+Ukgy1kzR33MXEF16lg7d+mUoYkAiBY1PXzItUr0LV60MNI8SUiCK9MvLIvkZSvV7d01HKC8WTuzxVgwNchyrZrVy5AiX6Rscet0okifQ9OG3VJy51KlZOC0hZgyqkUQRFfgfFLRRNWjNcu29RBRpkSQBxCiHCQYAinGmEZ1jljygaCDLkp5iBQYYUUOHVWqJrBQQOFCICkjBAQAOw==';</script><script>(function(){// glMatrix v0.9.5
glMatrixArrayType=typeof Float32Array!="undefined"?Float32Array:typeof WebGLFloatArray!="undefined"?WebGLFloatArray:Array;
var vec3={};
vec3.create=function(a){var b=new glMatrixArrayType(3);if(a){b[0]=a[0];b[1]=a[1];b[2]=a[2]}return b};
vec3.scale=function(a,b,c){if(!c||a==c){a[0]*=b;a[1]*=b;a[2]*=b;return a}c[0]=a[0]*b;c[1]=a[1]*b;c[2]=a[2]*b;return c};
vec3.normalize=function(a,b){b||(b=a);var c=a[0],d=a[1],e=a[2],g=Math.sqrt(c*c+d*d+e*e);if(g){if(g==1){b[0]=c;b[1]=d;b[2]=e;return b}}else{b[0]=0;b[1]=0;b[2]=0;return b}g=1/g;b[0]=c*g;b[1]=d*g;b[2]=e*g;return b};
var mat3={};
mat3.create=function(a){var b=new glMatrixArrayType(9);if(a){b[0]=a[0];b[1]=a[1];b[2]=a[2];b[3]=a[3];b[4]=a[4];b[5]=a[5];b[6]=a[6];b[7]=a[7];b[8]=a[8];b[9]=a[9]}return b};
mat3.transpose=function(a,b){if(!b||a==b){var c=a[1],d=a[2],e=a[5];a[1]=a[3];a[2]=a[6];a[3]=c;a[5]=a[7];a[6]=d;a[7]=e;return a}b[0]=a[0];b[1]=a[3];b[2]=a[6];b[3]=a[1];b[4]=a[4];b[5]=a[7];b[6]=a[2];b[7]=a[5];b[8]=a[8];return b};
var mat4={};
mat4.set=function(a,b){b[0]=a[0];b[1]=a[1];b[2]=a[2];b[3]=a[3];b[4]=a[4];b[5]=a[5];b[6]=a[6];b[7]=a[7];b[8]=a[8];b[9]=a[9];b[10]=a[10];b[11]=a[11];b[12]=a[12];b[13]=a[13];b[14]=a[14];b[15]=a[15];return b};mat4.identity=function(a){a[0]=1;a[1]=0;a[2]=0;a[3]=0;a[4]=0;a[5]=1;a[6]=0;a[7]=0;a[8]=0;a[9]=0;a[10]=1;a[11]=0;a[12]=0;a[13]=0;a[14]=0;a[15]=1;return a};
mat4.create=function(a){var b=new glMatrixArrayType(16);if(a){b[0]=a[0];b[1]=a[1];b[2]=a[2];b[3]=a[3];b[4]=a[4];b[5]=a[5];b[6]=a[6];b[7]=a[7];b[8]=a[8];b[9]=a[9];b[10]=a[10];b[11]=a[11];b[12]=a[12];b[13]=a[13];b[14]=a[14];b[15]=a[15]}return b};
mat4.identity=function(a){a[0]=1;a[1]=0;a[2]=0;a[3]=0;a[4]=0;a[5]=1;a[6]=0;a[7]=0;a[8]=0;a[9]=0;a[10]=1;a[11]=0;a[12]=0;a[13]=0;a[14]=0;a[15]=1;return a};
mat4.toInverseMat3=function(a,b){var c=a[0],d=a[1],e=a[2],g=a[4],f=a[5],h=a[6],i=a[8],j=a[9],k=a[10],l=k*f-h*j,o=-k*g+h*i,m=j*g-f*i,n=c*l+d*o+e*m;if(!n)return null;n=1/n;b||(b=mat3.create());b[0]=l*n;b[1]=(-k*d+e*j)*n;b[2]=(h*d-e*f)*n;b[3]=o*n;b[4]=(k*c-e*i)*n;b[5]=(-h*c+e*g)*n;b[6]=m*n;b[7]=(-j*c+d*i)*n;b[8]=(f*c-d*g)*n;return b};
mat4.multiply=function(a,b,c){c||(c=a);var d=a[0],e=a[1],g=a[2],f=a[3],h=a[4],i=a[5],j=a[6],k=a[7],l=a[8],o=a[9],m=a[10],n=a[11],p=a[12],r=a[13],s=a[14];a=a[15];var A=b[0],B=b[1],t=b[2],u=b[3],v=b[4],w=b[5],x=b[6],y=b[7],z=b[8],C=b[9],D=b[10],E=b[11],q=b[12],F=b[13],G=b[14];b=b[15];c[0]=A*d+B*h+t*l+u*p;c[1]=A*e+B*i+t*o+u*r;c[2]=A*g+B*j+t*m+u*s;c[3]=A*f+B*k+t*n+u*a;c[4]=v*d+w*h+x*l+y*p;c[5]=v*e+w*i+x*o+y*r;c[6]=v*g+w*j+x*m+y*s;c[7]=v*f+w*k+x*n+y*a;c[8]=z*d+C*h+D*l+E*p;c[9]=z*e+C*i+D*o+E*r;c[10]=z*
g+C*j+D*m+E*s;c[11]=z*f+C*k+D*n+E*a;c[12]=q*d+F*h+G*l+b*p;c[13]=q*e+F*i+G*o+b*r;c[14]=q*g+F*j+G*m+b*s;c[15]=q*f+F*k+G*n+b*a;return c};
mat4.translate=function(a,b,c){var d=b[0],e=b[1];b=b[2];if(!c||a==c){a[12]=a[0]*d+a[4]*e+a[8]*b+a[12];a[13]=a[1]*d+a[5]*e+a[9]*b+a[13];a[14]=a[2]*d+a[6]*e+a[10]*b+a[14];a[15]=a[3]*d+a[7]*e+a[11]*b+a[15];return a}var g=a[0],f=a[1],h=a[2],i=a[3],j=a[4],k=a[5],l=a[6],o=a[7],m=a[8],n=a[9],p=a[10],r=a[11];c[0]=g;c[1]=f;c[2]=h;c[3]=i;c[4]=j;c[5]=k;c[6]=l;c[7]=o;c[8]=m;c[9]=n;c[10]=p;c[11]=r;c[12]=g*d+j*e+m*b+a[12];c[13]=f*d+k*e+n*b+a[13];c[14]=h*d+l*e+p*b+a[14];c[15]=i*d+o*e+r*b+a[15];return c};
mat4.scale=function(a,b,c){var d=b[0],e=b[1];b=b[2];if(!c||a==c){a[0]*=d;a[1]*=d;a[2]*=d;a[3]*=d;a[4]*=e;a[5]*=e;a[6]*=e;a[7]*=e;a[8]*=b;a[9]*=b;a[10]*=b;a[11]*=b;return a}c[0]=a[0]*d;c[1]=a[1]*d;c[2]=a[2]*d;c[3]=a[3]*d;c[4]=a[4]*e;c[5]=a[5]*e;c[6]=a[6]*e;c[7]=a[7]*e;c[8]=a[8]*b;c[9]=a[9]*b;c[10]=a[10]*b;c[11]=a[11]*b;c[12]=a[12];c[13]=a[13];c[14]=a[14];c[15]=a[15];return c};
mat4.rotate=function(a,b,c,d){var e=c[0],g=c[1];c=c[2];var f=Math.sqrt(e*e+g*g+c*c);if(!f)return null;if(f!=1){f=1/f;e*=f;g*=f;c*=f}var h=Math.sin(b),i=Math.cos(b),j=1-i;b=a[0];f=a[1];var k=a[2],l=a[3],o=a[4],m=a[5],n=a[6],p=a[7],r=a[8],s=a[9],A=a[10],B=a[11],t=e*e*j+i,u=g*e*j+c*h,v=c*e*j-g*h,w=e*g*j-c*h,x=g*g*j+i,y=c*g*j+e*h,z=e*c*j+g*h;e=g*c*j-e*h;g=c*c*j+i;if(d){if(a!=d){d[12]=a[12];d[13]=a[13];d[14]=a[14];d[15]=a[15]}}else d=a;d[0]=b*t+o*u+r*v;d[1]=f*t+m*u+s*v;d[2]=k*t+n*u+A*v;d[3]=l*t+p*u+B*
v;d[4]=b*w+o*x+r*y;d[5]=f*w+m*x+s*y;d[6]=k*w+n*x+A*y;d[7]=l*w+p*x+B*y;d[8]=b*z+o*e+r*g;d[9]=f*z+m*e+s*g;d[10]=k*z+n*e+A*g;d[11]=l*z+p*e+B*g;return d};
mat4.frustum=function(a,b,c,d,e,g,f){f||(f=mat4.create());var h=b-a,i=d-c,j=g-e;f[0]=e*2/h;f[1]=0;f[2]=0;f[3]=0;f[4]=0;f[5]=e*2/i;f[6]=0;f[7]=0;f[8]=(b+a)/h;f[9]=(d+c)/i;f[10]=-(g+e)/j;f[11]=-1;f[12]=0;f[13]=0;f[14]=-(g*e*2)/j;f[15]=0;return f};
mat4.perspective=function(a,b,c,d,e){a=c*Math.tan(a*Math.PI/360);b=a*b;return mat4.frustum(-b,b,-a,a,c,d,e)};

var canvas = document.getElementById('scene'), 
    context = canvas.getContext('webgl'),
    shaderProgram = null, 
    mvMatrix = mat4.create(), 
    pMatrix = mat4.create(),
    mvMatrixStack = [];
function gl_init() {
  // init depth test
  context.enable(context.DEPTH_TEST);
};

function gl_clear() {
  context.viewport(0, 0, canvas.width, canvas.height);
  context.clear(context.COLOR_BUFFER_BIT | context.DEPTH_BUFFER_BIT);
};

function gl_save() {
  var copy = mat4.create();
  mat4.set(mvMatrix, copy);
  mvMatrixStack.push(copy);
};

function gl_restore() {
  if (mvMatrixStack.length == 0) {
    throw 'Invalid popMatrix!';
  }
  mvMatrix = mvMatrixStack.pop();
};

function gl_getFragmentShaderGLSL() {
  return '#ifdef GL_ES\n' +
    'precision highp float;\n' +
    '#endif\n' +
    'varying vec2 vTextureCoord;\n' +
    'varying vec3 vLightWeighting;\n' +
    'uniform sampler2D uSampler;\n' +
    'void main(void) {\n' +
    'vec4 textureColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));\n' +
    'gl_FragColor = vec4(textureColor.rgb * vLightWeighting, textureColor.a);\n' +
    '}';
};

function gl_getVertexShaderGLSL() {
  return 'attribute vec3 aVertexPosition;\n' +
    'attribute vec3 aVertexNormal;\n' +
    'attribute vec2 aTextureCoord;\n' +
    'uniform mat4 uMVMatrix;\n' +
    'uniform mat4 uPMatrix;\n' +
    'uniform mat3 uNMatrix;\n' +
    'uniform vec3 uAmbientColor;\n' +
    'uniform vec3 uLightingDirection;\n' +
    'uniform vec3 uDirectionalColor;\n' +
    'uniform bool uUseLighting;\n' +
    'varying vec2 vTextureCoord;\n' +
    'varying vec3 vLightWeighting;\n' +
    'void main(void) {\n' +
    'gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\n' +
    'vTextureCoord = aTextureCoord;\n' +
    'if (!uUseLighting) {\n' +
    'vLightWeighting = vec3(1.0, 1.0, 1.0);\n' +
    '} else {\n' +
    'vec3 transformedNormal = uNMatrix * aVertexNormal;\n' +
    'float directionalLightWeighting = max(dot(transformedNormal, uLightingDirection), 0.0);\n' +
    'vLightWeighting = uAmbientColor + uDirectionalColor * directionalLightWeighting;\n' +
    '}\n' +
    '}';
};

function gl_initShaders() {
  gl_initPositionShader();
  gl_initTextureShader();
  gl_initNormalShader();
  gl_initLightingShader();
};

function gl_setShaderProgram() {
  var fragmentGLSL = gl_getFragmentShaderGLSL();
  var vertexGLSL = gl_getVertexShaderGLSL();
  
  var fragmentShader = context.createShader(context.FRAGMENT_SHADER);
  context.shaderSource(fragmentShader, fragmentGLSL);
  context.compileShader(fragmentShader);
  
  var vertexShader = context.createShader(context.VERTEX_SHADER);
  context.shaderSource(vertexShader, vertexGLSL);
  context.compileShader(vertexShader);
  
  shaderProgram = context.createProgram();
  context.attachShader(shaderProgram, vertexShader);
  context.attachShader(shaderProgram, fragmentShader);
  context.linkProgram(shaderProgram);
  
  if (!context.getProgramParameter(shaderProgram, context.LINK_STATUS)) {
    alert('Could not initialize shaders');
  }
  
  context.useProgram(shaderProgram);
  
  // once shader program is loaded, it's time to init the shaders
  gl_initShaders();
};

function gl_perspective(viewAngle, minDist, maxDist) {
  mat4.perspective(viewAngle, canvas.width / canvas.height, minDist, maxDist, pMatrix);
};

function gl_identity() {
  mat4.identity(mvMatrix);
};

function gl_translate(x, y, z) {
  mat4.translate(mvMatrix, [x, y, z]);
};

function gl_rotate(angle, x, y, z) {
  mat4.rotate(mvMatrix, angle, [x, y, z]);
};

function gl_initPositionShader() {
  shaderProgram.vertexPositionAttribute = context.getAttribLocation(shaderProgram, 'aVertexPosition');
  context.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);
  shaderProgram.pMatrixUniform = context.getUniformLocation(shaderProgram, 'uPMatrix');
  shaderProgram.mvMatrixUniform = context.getUniformLocation(shaderProgram, 'uMVMatrix');
};

function gl_initColorShader() {
  shaderProgram.vertexColorAttribute = context.getAttribLocation(shaderProgram, 'aVertexColor');
  context.enableVertexAttribArray(shaderProgram.vertexColorAttribute);
};

function gl_initTextureShader() {
  shaderProgram.textureCoordAttribute = context.getAttribLocation(shaderProgram, 'aTextureCoord');
  context.enableVertexAttribArray(shaderProgram.textureCoordAttribute);
  shaderProgram.samplerUniform = context.getUniformLocation(shaderProgram, 'uSampler');
};

function gl_initNormalShader() {
  shaderProgram.vertexNormalAttribute = context.getAttribLocation(shaderProgram, 'aVertexNormal');
  context.enableVertexAttribArray(shaderProgram.vertexNormalAttribute);
  shaderProgram.nMatrixUniform = context.getUniformLocation(shaderProgram, 'uNMatrix');
};

function gl_initLightingShader() {
  shaderProgram.useLightingUniform = context.getUniformLocation(shaderProgram, 'uUseLighting');
  shaderProgram.ambientColorUniform = context.getUniformLocation(shaderProgram, 'uAmbientColor');
  shaderProgram.lightingDirectionUniform = context.getUniformLocation(shaderProgram, 'uLightingDirection');
  shaderProgram.directionalColorUniform = context.getUniformLocation(shaderProgram, 'uDirectionalColor');
};

function gl_initTexture(texture) {
  context.pixelStorei(context.UNPACK_FLIP_Y_WEBGL, true);
  context.bindTexture(context.TEXTURE_2D, texture);
  context.texImage2D(context.TEXTURE_2D, 0, context.RGBA, context.RGBA, context.UNSIGNED_BYTE, texture.image);
  context.texParameteri(context.TEXTURE_2D, context.TEXTURE_MAG_FILTER, context.NEAREST);
  context.texParameteri(context.TEXTURE_2D, context.TEXTURE_MIN_FILTER, context.LINEAR_MIPMAP_NEAREST);
  context.generateMipmap(context.TEXTURE_2D);
  context.bindTexture(context.TEXTURE_2D, null);
};

function gl_createArrayBuffer(vertices) {
  var buffer = context.createBuffer();
  buffer.numElements = vertices.length;
  context.bindBuffer(context.ARRAY_BUFFER, buffer);
  context.bufferData(context.ARRAY_BUFFER, new Float32Array(vertices), context.STATIC_DRAW);
  return buffer;
};

function gl_createElementArrayBuffer(vertices) {
  var buffer = context.createBuffer();
  buffer.numElements = vertices.length;
  context.bindBuffer(context.ELEMENT_ARRAY_BUFFER, buffer);
  context.bufferData(context.ELEMENT_ARRAY_BUFFER, new Uint16Array(vertices), context.STATIC_DRAW);
  return buffer;
};

function gl_pushPositionBuffer(buffers) {
  context.bindBuffer(context.ARRAY_BUFFER, buffers.positionBuffer);
  context.vertexAttribPointer(shaderProgram.vertexPositionAttribute, 3, context.FLOAT, false, 0, 0);
};


function gl_pushColorBuffer(buffers) {
  context.bindBuffer(context.ARRAY_BUFFER, buffers.colorBuffer);
  context.vertexAttribPointer(shaderProgram.vertexColorAttribute, 4, context.FLOAT, false, 0, 0);
};

function gl_pushTextureBuffer(buffers, texture) {
  context.bindBuffer(context.ARRAY_BUFFER, buffers.textureBuffer);
  context.vertexAttribPointer(shaderProgram.textureCoordAttribute, 2, context.FLOAT, false, 0, 0);
  context.activeTexture(context.TEXTURE0);
  context.bindTexture(context.TEXTURE_2D, texture);
  context.uniform1i(shaderProgram.samplerUniform, 0);
};

function gl_pushIndexBuffer(buffers) {
  context.bindBuffer(context.ELEMENT_ARRAY_BUFFER, buffers.indexBuffer);
};

function gl_pushNormalBuffer(buffers) {
  context.bindBuffer(context.ARRAY_BUFFER, buffers.normalBuffer);
  context.vertexAttribPointer(shaderProgram.vertexNormalAttribute, 3, context.FLOAT, false, 0, 0);
};

function gl_setMatrixUniforms() {
  context.uniformMatrix4fv(shaderProgram.pMatrixUniform, false, pMatrix);
  context.uniformMatrix4fv(shaderProgram.mvMatrixUniform, false, mvMatrix);
  
  var normalMatrix = mat3.create();
  mat4.toInverseMat3(mvMatrix, normalMatrix);
  mat3.transpose(normalMatrix);
  context.uniformMatrix3fv(shaderProgram.nMatrixUniform, false, normalMatrix);
};

function gl_drawElements(buffers) {
  gl_setMatrixUniforms();
  
  // draw elements
  context.drawElements(context.TRIANGLES, buffers.indexBuffer.numElements, context.UNSIGNED_SHORT, 0);
};

function l_drawArrays(buffers) {
  gl_setMatrixUniforms();
  
  // draw arrays
  context.drawArrays(context.TRIANGLES, 0, buffers.positionBuffer.numElements / 3);
};

function gl_enableLighting() {
  context.uniform1i(shaderProgram.useLightingUniform, true);
};

function gl_setAmbientLighting(red, green, blue) {
  context.uniform3f(shaderProgram.ambientColorUniform, parseFloat(red), parseFloat(green), parseFloat(blue));
};

function gl_setDirectionalLighting(x, y, z, red, green, blue) {
  // directional lighting
  var lightingDirection = [x, y, z];
  var adjustedLD = vec3.create();
  vec3.normalize(lightingDirection, adjustedLD);
  vec3.scale(adjustedLD, -1);
  context.uniform3fv(shaderProgram.lightingDirectionUniform, adjustedLD);
  
  // directional color
  context.uniform3f(shaderProgram.directionalColorUniform, parseFloat(red), parseFloat(green), parseFloat(blue));
};
            /*************************************
             * Model
             */
            function Model() {
                this.cubeBuffers = {};
                this.floorBuffers = {};
                this.wallBuffers = {};
                this.angle = 0;
                this.textures = {};
                this.cratePositions = [];
                
                // movements
                this.STILL = 'STILL';
                this.FORWARD = 'FORWARD';
                this.BACKWARD = 'BACKWARD';
                this.LEFT = 'LEFT';
                this.RIGHT = 'RIGHT';
                
                // camera
                this.camera = {
                    x: 0,
                    y: 1.5,
                    z: 5,
                    pitch: 0,
                    yaw: 0
                };
                
                this.straightMovement = this.STILL;
                this.sideMovement = this.STILL;
                this.speed = 8; // units per second 
                this.initBuffers();
                this.initCratePositions();
            }
            
            Model.prototype.initCratePositions = function() {
                var crateRange = 45;
                // randomize 20 floor crates
                for (var n = 0; n < 20; n++) {
                    var cratePos = {};
                    cratePos.x = (Math.random() * crateRange * 2) - crateRange;
                    cratePos.y = 0;
                    cratePos.z = (Math.random() * crateRange * 2) - crateRange;
                    cratePos.rotationY = Math.random() * Math.PI * 2;
                    this.cratePositions.push(cratePos);
                    
                    if (Math.round(Math.random() * 3) == 3) {
                        var stackedCratePosition = {};
                        stackedCratePosition.x = cratePos.x;
                        stackedCratePosition.y = 2.01;
                        stackedCratePosition.z = cratePos.z;
                        stackedCratePosition.rotationY = cratePos.rotationY + ((Math.random() * Math.PI / 8) - Math.PI / 16);
                        this.cratePositions.push(stackedCratePosition);
                    }
                }
            };
            
            Model.prototype.initCubeBuffers = function() {
                this.cubeBuffers.positionBuffer = gl_createArrayBuffer([    
                  -1, -1, 1, 1, -1, 1, 1, 1, 1, -1, 1, 1, // Front face    
                  -1, -1, -1, -1, 1, -1, 1, 1, -1, 1, -1, -1, // Back face    
                  -1, 1, -1, -1, 1, 1, 1, 1, 1, 1, 1, -1, // Top face    
                  -1, -1, -1, 1, -1, -1, 1, -1, 1, -1, -1, 1, // Bottom face    
                  1, -1, -1, 1, 1, -1, 1, 1, 1, 1, -1, 1, // Right face    
                  -1, -1, -1, -1, -1, 1, -1, 1, 1, -1, 1, -1 // Left face
        ]);
                
                this.cubeBuffers.normalBuffer = gl_createArrayBuffer([    
                  0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, // Front face    
                  0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, // Back face   
                  0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, // Top face    
                  0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, // Bottom face    
                  1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, // Right face    
                  -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0 // Left face
        ]);
                
                this.cubeBuffers.textureBuffer = gl_createArrayBuffer([    
                  0, 0, 1, 0, 1, 1, 0, 1, // Front face   
                  1, 0, 1, 1, 0, 1, 0, 0, // Back face   
                  0, 1, 0, 0, 1, 0, 1, 1, // Top face    
                  1, 1, 0, 1, 0, 0, 1, 0, // Bottom face   
                  1, 0, 1, 1, 0, 1, 0, 0, // Right face    
                  0, 0, 1, 0, 1, 1, 0, 1 // Left face
        ]);
                
                this.cubeBuffers.indexBuffer = gl_createElementArrayBuffer([
          0, 1, 2, 0, 2, 3, // Front face
                4, 5, 6, 4, 6, 7, // Back face
                8, 9, 10, 8, 10, 11, // Top face
                12, 13, 14, 12, 14, 15, // Bottom face
                16, 17, 18, 16, 18, 19, // Right face
                20, 21, 22, 20, 22, 23 // Left face
              ]);
            };
            
            Model.prototype.initFloorBuffers = function() {
                this.floorBuffers.positionBuffer = gl_createArrayBuffer([
          -50, 0, -50, -50, 0, 50, 50, 0, 50, 50, 0, -50
        ]);
                
                this.floorBuffers.textureBuffer = gl_createArrayBuffer([
          0, 25, 0, 0, 25, 0, 25, 25
        ]);
                
                this.floorBuffers.indexBuffer = gl_createElementArrayBuffer([
          0, 1, 2, 0, 2, 3
        ]);
                
                // floor normal points upwards
                this.floorBuffers.normalBuffer = gl_createArrayBuffer([
          0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0
        ]);
            };
            
            Model.prototype.initWallBuffers = function() {
                this.wallBuffers.positionBuffer = gl_createArrayBuffer([
          -50, 5, 0, 50, 5, 0, 50, -5, 0, -50, -5, 0
        ]);
                
                this.wallBuffers.textureBuffer = gl_createArrayBuffer([
          0, 0, 25, 0, 25, 1.5, 0, 1.5
        ]);
                
                this.wallBuffers.indexBuffer = gl_createElementArrayBuffer([
          0, 1, 2, 0, 2, 3
        ]);
                
                // floor normal points upwards
                this.wallBuffers.normalBuffer = gl_createArrayBuffer([
          0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1
        ]);
            };
            
            Model.prototype.initBuffers = function() {
                this.initCubeBuffers();
                this.initFloorBuffers();
                this.initWallBuffers();
            };
            
            Model.prototype.updateCameraPos = function() {
                if (this.straightMovement != this.STILL) {
                    var direction = this.straightMovement == this.FORWARD ? -1 : 1;
                    var distEachFrame = direction * this.speed * 0 / 1000;
                    this.camera.z += distEachFrame * Math.cos(this.camera.yaw);
                    this.camera.x += distEachFrame * Math.sin(this.camera.yaw);
                }
                
                if (this.sideMovement != this.STILL) {
                    var direction = this.sideMovement == this.RIGHT ? 1 : -1;
                    var distEachFrame = direction * this.speed * 0 / 1000;
                    this.camera.z += distEachFrame * Math.cos(this.camera.yaw + Math.PI / 2);
                    this.camera.x += distEachFrame * Math.sin(this.camera.yaw + Math.PI / 2);
                }
            };
            /*************************************
             * View
             */
            function View(){
                this.canvas = document.getElementById('scene');
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
            }
            
            View.prototype.drawFloor = function(){
                var floorBuffers = model.floorBuffers;
                
                gl_save();
                gl_translate(0, -1.1, 0);
                gl_pushPositionBuffer(floorBuffers);
                gl_pushNormalBuffer(floorBuffers);
                gl_pushTextureBuffer(floorBuffers, model.textures.metalFloor);
                gl_pushIndexBuffer(floorBuffers);
                gl_drawElements(floorBuffers);
                gl_restore();
            };
            
            View.prototype.drawCeiling = function(){
                var floorBuffers = model.floorBuffers;
                
                gl_save();
                gl_translate(0, 8.9, 0);
                // use floor buffers with ceiling texture
                gl_pushPositionBuffer(floorBuffers);
                gl_pushNormalBuffer(floorBuffers);
                gl_pushTextureBuffer(floorBuffers, model.textures.ceiling);
                gl_pushIndexBuffer(floorBuffers);
                gl_drawElements(floorBuffers);
                gl_restore();
            };
            
            View.prototype.drawCrates = function(){
                var cubeBuffers = model.cubeBuffers;
                
                for (var n = 0; n < model.cratePositions.length; n++) {
                    gl_save();
                    var cratePos = model.cratePositions[n];
                    gl_translate(cratePos.x, cratePos.y, cratePos.z);
                    gl_rotate(cratePos.rotationY, 0, 1, 0);
                    gl_pushPositionBuffer(cubeBuffers);
                    gl_pushNormalBuffer(cubeBuffers);
                    gl_pushTextureBuffer(cubeBuffers, model.textures.crate);
                    gl_pushIndexBuffer(cubeBuffers);
                    gl_drawElements(cubeBuffers);
                    gl_restore();
                }
            };
            
            View.prototype.drawWalls = function(){
                var wallBuffers = model.wallBuffers;
                var metalWallTexture = model.textures.metalWall;
                
                gl_save();
                gl_translate(0, 3.9, -50);
                gl_pushPositionBuffer(wallBuffers);
                gl_pushNormalBuffer(wallBuffers);
                gl_pushTextureBuffer(wallBuffers, metalWallTexture);
                gl_pushIndexBuffer(wallBuffers);
                gl_drawElements(wallBuffers);
                gl_restore();
                
                gl_save();
                gl_translate(0, 3.9, 50);
                gl_rotate(Math.PI, 0, 1, 0);
                gl_pushPositionBuffer(wallBuffers);
                gl_pushNormalBuffer(wallBuffers);
                gl_pushTextureBuffer(wallBuffers, metalWallTexture);
                gl_pushIndexBuffer(wallBuffers);
                gl_drawElements(wallBuffers);
                gl_restore();
                
                gl_save();
                gl_translate(50, 3.9, 0);
                gl_rotate(Math.PI * 1.5, 0, 1, 0);
                gl_pushPositionBuffer(wallBuffers);
                gl_pushNormalBuffer(wallBuffers);
                gl_pushTextureBuffer(wallBuffers, metalWallTexture);
                gl_pushIndexBuffer(wallBuffers);
                gl_drawElements(wallBuffers);
                gl_restore();
                
                gl_save();
                gl_translate(-50, 3.9, 0);
                gl_rotate(Math.PI / 2, 0, 1, 0);
                gl_pushPositionBuffer(wallBuffers);
                gl_pushNormalBuffer(wallBuffers);
                gl_pushTextureBuffer(wallBuffers, metalWallTexture);
                gl_pushIndexBuffer(wallBuffers);
                gl_drawElements(wallBuffers);
                gl_restore();
            };
            
            View.prototype.stage = function(){
                var camera = model.camera;
                model.updateCameraPos();
        
                gl_clear();
        
                // set field of view at 45 degrees
                // set viewing range between 0.1 and 100 units away.
                gl_perspective(45, 0.1, 150.0);
                gl_identity();
                
                gl_rotate(-camera.pitch, 1, 0, 0);
                gl_rotate(-camera.yaw, 0, 1, 0);
                gl_translate(-camera.x, -camera.y, -camera.z);
                
                // enable lighting
                gl_enableLighting();
                gl_setAmbientLighting(0.5, 0.5, 0.5);
                gl_setDirectionalLighting(-0.25, -0.25, -1, 0.8, 0.8, 0.8);
                
                view.drawFloor();
                view.drawWalls();
                view.drawCeiling();
                view.drawCrates();
            };
var view = new View(),
    model = new Model();

function c_init() {
  gl_init();
  gl_setShaderProgram();
  c_attachListeners();
  
  var sources = {
    crate: GROUND_TEXTURE_ENCODING,
    metalFloor: GROUND_TEXTURE_ENCODING,
    metalWall: GROUND_TEXTURE_ENCODING,
    ceiling: GROUND_TEXTURE_ENCODING
  };
  
  c_loadTextures(sources, function() {
    view.stage();
  });
}

function c_loadTextures(sources, callback) {
  var textures = model.textures;
  var loadedImages = 0;
  var numImages = 0;
  for (var src in sources) {
    (function() {
      var key = src;
      numImages++;
      textures[key] = context.createTexture();
      textures[key].image = new Image();
      textures[key].image.onload = function() {
        gl_initTexture(textures[key]);
        if (++loadedImages >= numImages) {
            callback();
        }
      };
      
      textures[key].image.src = sources[key];
    })();
  }
};

function c_handleKeyDown(evt) {
  var keycode = ((evt.which) || (evt.keyCode));
  switch (keycode) {
    case 37:
      // left key
      model.sideMovement = model.LEFT;
      break;
    case 38:
      // up key
      model.straightMovement = model.FORWARD;
      break;
    case 39:
      // right key
      model.sideMovement = model.RIGHT;
      break;
    case 40:
      // down key
      model.straightMovement = model.BACKWARD;
      break;
  }
};

function c_handleKeyUp(evt) {
  var keycode = ((evt.which) || (evt.keyCode));
  switch (keycode) {
    case 37:
      // left key
      model.sideMovement = model.STILL;
      break;
    case 38:
      // up key
      model.straightMovement = model.STILL;
      break;
    case 39:
      // right key
      model.sideMovement = model.STILL;
      break;
    case 40:
      // down key
      model.straightMovement = model.STILL;
      break;
  }
};

function c_attachListeners() {
  document.addEventListener('keydown', function(evt) {
    c_handleKeyDown(evt);
  }, false);
  
  document.addEventListener('keyup', function(evt) {
    c_handleKeyUp(evt);
  }, false);
};

// initialize game controller
c_init();
            })();</script></body></html>